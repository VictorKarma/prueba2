 #include <fstream>
#include <stdlib.h>
 #include <stdio.h>
 #include <string.h>

#include <windows.h>
#include <iostream>
usando el espacio de nombres estándar;

typedef std :: basic_ifstream <TCHAR> tifstream;
typedef std :: basic_string <TCHAR> tstring;

nulo Outtextxy (HDC hdc, int x, int y, tstring Msg)
{
TextOut (hdc, x, y, Msg.c_str (), static_cast <int> (Msg.length ()));
}

ShowError nulo (tstring strMsg)
{
MessageBox (NULL, strMsg.c_str (), TEXT ("Imprimir"), MB_ICONERROR);
salida (1);
}
nulo ShowInformation (tstring strText)
{
MessageBox (NULL, strText.c_str (), TEXT ("Imprimir"), MB_ICONINFORMATION);
}
nulo PrintFile (tifstream & f)
{
PRINTDLG pd;
DOCINFO di;
tstring strLine;
int y = 300;

memset (& pd, 0, sizeof (PRINTDLG));
memset (& di, 0, sizeof (DOCINFO));

di.cbSize = sizeof (DOCINFO);
di.lpszDocName = TEXTO ("Imprimiendo");

pd.lStructSize = sizeof (PRINTDLG);
pd.Flags = PD_PAGENUMS | PD_RETURNDC;
pd.nFromPage = 1;
pd.nToPage = 1;
pd.nMinPage = 1;
pd.nMaxPage = 0xFFFF;


if (f.fail ())
ShowError (TEXTO ("Error el archivo no se pudo abrir para lectura"));

if (PrintDlg (& pd)) {
if (pd.hDC) {
if (StartDoc (pd.hDC, & di)! = SP_ERROR) {
cout << "Imprimiendo ... \ nEspere un momento" << endl;
StartPage (pd.hDC);
while (! f.eof ()) {
getline (f, strLine);
Outtextxy (pd.hDC, 500, y, strLine.c_str ());
y + = 100;
}
EndPage (pd.hDC);
EndDoc (pd.hDC);

}
más
ShowError (TEXT ("Error: No se pudo comenzar a imprimir."));

}
más
ShowError (TEXT ("Error: No se pudo crear el contexto de dispositivo"));

}
más
ShowInformation (TEXTO ("Se cancelo la impresion"));

ShowInformation (TEXTO ("Termino la impresion correctamente."));
}

estructura typedef
{
	char Nombre [50];
	char Correo [50];
	Char Telefono [50];
} TPersonas;

TPersonas Personas [25];
int n;

lectura nula (int i)
{

		fflush (stdin);
	    printf ("\ nDame el nombre de la persona [% d]:", i);
	    scanf ("% 100 [^ \ n]", Personas [i] .Nombre);
	    printf ("Dame el Correo:");
	    scanf ("% s", & Personas [i] .Correo);
	    printf ("Dame el Telefono:");
	    scanf ("% s", & Personas [i] .Telefono);
	    printf ("\ n");
} // fin leer

vacío mostrar (int i, int n)
{
	para (i = 1; i <n; i ++)
	{

		printf ("\ nDatos de la persona [% d]:", i);
		printf ("\ nNombre:% s", Personas [i] .Nombre);
		printf ("\ n Correo:% s", Personas [i] .Correo);
		printf ("\ nTelefono:% s", Personas [i] .Telefono);
		printf ("\ n");
	}
} // fin mostrar

anular guardar (int i, int n)
{
	ARCHIVO * ARCHIVO;
	ARCHIVO = fopen ("Pruebas.txt", "wt");
	para (i = 1; i <n; i ++)
	{
		fprintf (ARCHIVO, "\ nDatos de la Persona [% d]:", i);
		fprintf (ARCHIVO, "\ nNombre:% s", Personas [i] .Nombre);
		fprintf (ARCHIVO, "\ n Correo:% s", Personas [i] .Correo);
		fprintf (ARCHIVO, "\ nTelefono:% s", Personas [i] .Telefono);
		fprintf (ARCHIVO, "\ n");
	}
	fclose (ARCHIVO);
}

contactos nulos (int n) {
	int aux, i, j;
	char auxc [50];

	sistema ("cls");

	para (i = 1; i <n; i ++) {
		para (j = 1; j <ni; j ++) {
			if (strcmp (Personas [j] .Nombre, Personas [j + 1] .Nombre)> 0) {

				strcpy (auxc, Personas [j] .Nombre);
				strcpy (Personas [j] .Nombre, Personas [j + 1] .Nombre);
				strcpy (Personas [j + 1] .Nombre, auxc);

				strcpy (auxc, Personas [j] .Correo);
				strcpy (Personas [j] .Correo, Personas [j + 1] .Correo);
				strcpy (Personas [j + 1]. Correo, auxc);

				strcpy (auxc, Personas [j] .Telefono);
				strcpy (Personas [j] .Telefono, Personas [j + 1] .Telefono);
				strcpy (Personas [j + 1] .Telefono, auxc);
			}
		}
	}
}

int main (int argc, char * argv []) /////////////////////// int main
{
	 char texto [256];
    ofstream impresora ("PRN");
    ifstream archivo ("Pruebas.txt");
	int n = 1;
	int opc;
	int i = 1;

	printf ("Programa que Captura datos para una agenda \ n");
	printf ("MENÚ \ n");

    hacer
    {
        printf ("\ n1.Agregar contacto \ t2.Monstrar Contactos \ t3.Guardar contactos \ t 4. contactos \ n");
        printf ("\ n \ n elección opcion (1-4):");
        scanf ("% d", & opc);

        interruptor (opc)
        {
            caso 1:
					leer (i);
					 i ++;
         			 n ++;
                    rotura;

            caso 2: mostrar (i, n);
                    rotura;

            caso 3: contactos (n);
					guardar (i, n);
            		printf ("\ n \ n \ n \ tCONTACTOS GUARDADOS !!!!! \ n \ n");
                    rotura;
         }

    } while (opc! = 4);

	printf ("Gracias por Usarme:) \ n \ n ADIOOSSS !!!!");

	tifstream en (TEXTO ("Pruebas.txt"));
    PrintFile (en);
    cercar();

	devuelve 0;
}
